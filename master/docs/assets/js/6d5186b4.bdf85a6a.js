"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[6239],{456:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>l});var n=i(4848),a=i(8453);const s={sidebar_position:20},o="Plutus Tx code",r={id:"simple-example/plutus-tx-code",title:"Plutus Tx code",description:"Recall that Plutus Tx is a subset of Haskell.",source:"@site/docs/simple-example/plutus-tx-code.md",sourceDirName:"simple-example",slug:"/simple-example/plutus-tx-code",permalink:"/plutus/master/docs/simple-example/plutus-tx-code",draft:!1,unlisted:!1,editUrl:"https://github.com/IntersectMBO/plutus/edit/master/docusaurus/docs/simple-example/plutus-tx-code.md",tags:[],version:"current",sidebarPosition:20,frontMatter:{sidebar_position:20},sidebar:"tutorialSidebar",previous:{title:"Auction properties",permalink:"/plutus/master/docs/simple-example/auction-properties"},next:{title:"Life cycle of the auction smart contract",permalink:"/plutus/master/docs/simple-example/life-cycle"}},d={},l=[{value:"Data types",id:"data-types",level:2},{value:"1. Contract parameters",id:"1-contract-parameters",level:3},{value:"2. Datum",id:"2-datum",level:3},{value:"3. Redeemer",id:"3-redeemer",level:3},{value:"4. Script context",id:"4-script-context",level:3},{value:"Main validator function",id:"main-validator-function",level:2},{value:"Sufficient bid condition",id:"sufficient-bid-condition",level:3},{value:"Valid bid time condition",id:"valid-bid-time-condition",level:3},{value:"Refunds previous highest bid condition",id:"refunds-previous-highest-bid-condition",level:3},{value:"Correct new datum condition",id:"correct-new-datum-condition",level:3},{value:"Compiling the validator",id:"compiling-the-validator",level:3}];function c(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",p:"p",strong:"strong",...(0,a.R)(),...e.components},{LiteralInclude:i}=t;return i||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("LiteralInclude",!0),(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"plutus-tx-code",children:"Plutus Tx code"}),"\n",(0,n.jsxs)(t.p,{children:["Recall that Plutus Tx is a subset of Haskell.\nIt is the source language one uses to write Plutus validators.\nA Plutus Tx program is compiled into Plutus Core, which is interpreted on-chain.\nThe full Plutus Tx code for the auction smart contract can be found at ",(0,n.jsx)(t.a,{href:"https://github.com/IntersectMBO/plutus/blob/master/doc/read-the-docs-site/tutorials/AuctionValidator.hs",children:"AuctionValidator.hs"}),"."]}),"\n",(0,n.jsx)(t.h2,{id:"data-types",children:"Data types"}),"\n",(0,n.jsx)(t.p,{children:"First, let's define the following data types and instances for the validator:"}),"\n",(0,n.jsx)(i,{file:"AuctionValidator.hs",language:"haskell",title:"Data types",start:"-- BLOCK1",end:"-- BLOCK2"}),"\n",(0,n.jsxs)(t.p,{children:["The purpose of ",(0,n.jsx)(t.code,{children:"makeLift"})," and ",(0,n.jsx)(t.code,{children:"unstableMakeIsData"})," will be explained later."]}),"\n",(0,n.jsx)(t.p,{children:"Typically, writing a Plutus Tx validator script for a smart contract involves four data types:"}),"\n",(0,n.jsx)(t.h3,{id:"1-contract-parameters",children:"1. Contract parameters"}),"\n",(0,n.jsxs)(t.p,{children:["These are fixed properties of the contract.\nIn our example, it is the ",(0,n.jsx)(t.code,{children:"AuctionParams"})," type, containing properties like seller and minimum bid."]}),"\n",(0,n.jsx)(t.h3,{id:"2-datum",children:"2. Datum"}),"\n",(0,n.jsxs)(t.p,{children:["This is part of a script UTXO.\nIt should be thought of as the state of the contract.\nOur example requires only one piece of state: the current highest bid.\nWe use the ",(0,n.jsx)(t.code,{children:"AuctionDatum"})," type to represent this."]}),"\n",(0,n.jsx)(t.h3,{id:"3-redeemer",children:"3. Redeemer"}),"\n",(0,n.jsxs)(t.p,{children:["This is an input to the Plutus script provided by the transaction that is trying to spend a script UTXO.\nIf a smart contract is regarded as a state machine, the redeemer would be the input that ticks the state machine.\nIn our example, it is the ",(0,n.jsx)(t.code,{children:"AuctionRedeemer"})," type: one may either submit a new bid, or request to close the auction and pay out the winner and the seller, both of which lead to a new state of the auction."]}),"\n",(0,n.jsx)(t.h3,{id:"4-script-context",children:"4. Script context"}),"\n",(0,n.jsx)(t.p,{children:"This type contains the information of the transaction that the validator can inspect.\nIn our example, our validator verifies several conditions of the transaction; e.g., if it is a new bid, then it must be submitted before the auction's end time; the previous highest bid must be refunded to the previous bidder, etc."}),"\n",(0,n.jsxs)(t.p,{children:["The script context type is fixed for each Plutus language version.\nFor Plutus V2, for example, it is ",(0,n.jsx)(t.code,{children:"PlutusLedgerApi.V2.Contexts.ScriptContext"}),"."]}),"\n",(0,n.jsxs)(t.blockquote,{children:["\n",(0,n.jsxs)(t.p,{children:["\ud83d\udccc"," ",(0,n.jsx)(t.strong,{children:"NOTE"})]}),"\n",(0,n.jsxs)(t.p,{children:["When writing a Plutus validator using Plutus Tx, it is advisable to turn off Haskell's ",(0,n.jsx)(t.code,{children:"Prelude"}),".\nUsage of most functions and methods in ",(0,n.jsx)(t.code,{children:"Prelude"})," should be replaced by their counterparts in the ",(0,n.jsx)(t.code,{children:"plutus-tx"})," library, e.g., ",(0,n.jsx)(t.code,{children:"PlutusTx.Eq.=="}),"."]}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"main-validator-function",children:"Main validator function"}),"\n",(0,n.jsx)(t.p,{children:"Now we are ready to introduce our main validator function.\nThe beginning of the function looks like the following:"}),"\n",(0,n.jsx)(i,{file:"AuctionValidator.hs",language:"haskell",title:"Main validator function",start:"-- BLOCK2",end:"-- BLOCK3"}),"\n",(0,n.jsx)(t.p,{children:"Depending on whether this transaction is attempting to submit a new bid or to request payout, the validator validates the corresponding set of conditions."}),"\n",(0,n.jsx)(t.h3,{id:"sufficient-bid-condition",children:"Sufficient bid condition"}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"sufficientBid"})," condition verifies that the bid amount is sufficient:"]}),"\n",(0,n.jsx)(i,{file:"AuctionValidator.hs",language:"haskell",title:"Sufficient bid condition",start:"-- BLOCK3",end:"-- BLOCK4"}),"\n",(0,n.jsx)(t.h3,{id:"valid-bid-time-condition",children:"Valid bid time condition"}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"validBidTime"})," condition verifies that the bid is submitted before the auction's deadline:"]}),"\n",(0,n.jsx)(i,{file:"AuctionValidator.hs",language:"haskell",title:"Valid bid time condition",start:"-- BLOCK4",end:"-- BLOCK5"}),"\n",(0,n.jsxs)(t.p,{children:["Here, ",(0,n.jsx)(t.code,{children:"to x"})," is the time interval ending at ",(0,n.jsx)(t.code,{children:"x"}),", i.e., ",(0,n.jsx)(t.code,{children:"(-\u221e, x]"}),".\n",(0,n.jsx)(t.code,{children:"txInfoValidRange"})," is a transaction property.\nIt is the time interval in which the transaction is allowed to go through phase-1 validation.\n",(0,n.jsx)(t.code,{children:"contains"})," takes two time intervals, and checks that the first interval completely includes the second.\nSince the transaction may be validated at any point in the ",(0,n.jsx)(t.code,{children:"txInfoValidRange"})," interval, we need to check that the entire interval lies within ",(0,n.jsx)(t.code,{children:"(-\u221e, apEndTime params]"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["The reason we need the ",(0,n.jsx)(t.code,{children:"txInfoValidRange"})," interval instead of using the exact time the transaction is validated is due to ",(0,n.jsx)(t.a,{href:"https://iohk.io/en/blog/posts/2021/09/06/no-surprises-transaction-validation-on-cardano/",children:"determinism"}),".\nUsing the exact time would be like calling a ",(0,n.jsx)(t.code,{children:"getCurrentTime"})," function and branching based on the current time.\nOn the other hand, by using the ",(0,n.jsx)(t.code,{children:"txInfoValidRange"})," interval, the same interval is always used by the same transaction."]}),"\n",(0,n.jsx)(t.h3,{id:"refunds-previous-highest-bid-condition",children:"Refunds previous highest bid condition"}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"refundsPreviousHighestBid"})," condition checks that the transaction pays the previous highest bid to the previous bidder:"]}),"\n",(0,n.jsx)(i,{file:"AuctionValidator.hs",language:"haskell",title:"Refunds previous highest bid condition",start:"-- BLOCK5",end:"-- BLOCK6"}),"\n",(0,n.jsxs)(t.p,{children:["It uses ",(0,n.jsx)(t.code,{children:"PlutusTx.find"})," to find the transaction output (a UTXO) that pays to the previous bidder the amount equivalent to the previous highest bid, and verifies that there is at least one such output."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"lovelaceValue amt"})," constructs a ",(0,n.jsx)(t.code,{children:"Value"})," with ",(0,n.jsx)(t.code,{children:"amt"})," Lovelaces (the subunit of the Ada currency).\n",(0,n.jsx)(t.code,{children:"Value"})," is a multi-asset type that represents a collection of assets, including Ada.\nAn asset is identified by a (symbol, token) pair, where the symbol represents the policy that controls the minting and burning of tokens, and the token represents a particular kind of token manipulated by the policy.\n",(0,n.jsx)(t.code,{children:"(adaSymbol, adaToken)"})," is the special identifier for Ada/Lovelace."]}),"\n",(0,n.jsx)(t.h3,{id:"correct-new-datum-condition",children:"Correct new datum condition"}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"correctNewDatum"})," condition verifies that the transaction produces a ",(0,n.jsx)(t.em,{children:"continuing output"})," containing the correct datum (the new highest bid):"]}),"\n",(0,n.jsx)(i,{file:"AuctionValidator.hs",language:"haskell",title:"Correct new datum condition",start:"-- BLOCK6",end:"-- BLOCK7"}),"\n",(0,n.jsx)(t.p,{children:'A "continuing output" is a transaction output that pays to the same script address from which we are currently spending.\nExactly one continuing output must be present in this example so that the next bidder can place a new bid.\nThe new bid, in turn, will need to spend the continuing output and get validated by the same validator script.'}),"\n",(0,n.jsxs)(t.p,{children:["If the transaction is requesting a payout, the validator will then verify the other three conditions: ",(0,n.jsx)(t.code,{children:"validPayoutTime"}),",",(0,n.jsx)(t.code,{children:"sellerGetsHighestBid"})," and ",(0,n.jsx)(t.code,{children:"highestBidderGetsAsset"}),".\nThese conditions are similar to the ones already explained, so their details are omitted."]}),"\n",(0,n.jsx)(t.h3,{id:"compiling-the-validator",children:"Compiling the validator"}),"\n",(0,n.jsx)(t.p,{children:"Finally, we need to compile the validator written in Plutus Tx into Plutus Core, using the Plutus Tx compiler:"}),"\n",(0,n.jsx)(i,{file:"AuctionValidator.hs",language:"haskell",title:"Compiling the validator",start:"-- BLOCK8",end:"-- BLOCK9"}),"\n",(0,n.jsxs)(t.p,{children:["The type of the compiled validator is ",(0,n.jsx)(t.code,{children:"CompiledCode (BuiltinData -> BuiltinData -> BuiltinData -> ())"}),", where type ",(0,n.jsx)(t.code,{children:"BuiltinData -> BuiltinData -> BuiltinData -> ()"})," is also known as the ",(0,n.jsx)(t.em,{children:"untyped validator"}),".\nAn untyped validator takes three ",(0,n.jsx)(t.code,{children:"BuiltinData"})," arguments, representing the serialized datum, redeemer, and script context.\nThe call to ",(0,n.jsx)(t.code,{children:"PlutusTx.unsafeFromBuiltinData"})," is the reason we need the ",(0,n.jsx)(t.code,{children:"PlutusTx.unstableMakeIsData"})," shown before, which derives ",(0,n.jsx)(t.code,{children:"UnsafeFromData"})," instances.\nAnd instead of returning a ",(0,n.jsx)(t.code,{children:"Bool"}),", it simply returns ",(0,n.jsx)(t.code,{children:"()"}),", and the validation succeeds if the script evaluates without error."]}),"\n",(0,n.jsxs)(t.p,{children:["Note that ",(0,n.jsx)(t.code,{children:"AuctionParams"})," is an argument of neither the untyped validator nor the final UPLC program.\n",(0,n.jsx)(t.code,{children:"AuctionParams"})," contains contract properties that don't change, so it is simply built into the validator."]}),"\n",(0,n.jsxs)(t.p,{children:["Since the Plutus Tx compiler compiles ",(0,n.jsx)(t.code,{children:"a"})," into ",(0,n.jsx)(t.code,{children:"CompiledCode a"}),", we first use ",(0,n.jsx)(t.code,{children:"auctionUntypedValidator"})," to obtain an untyped validator.\nIt takes ",(0,n.jsx)(t.code,{children:"AuctionParams"}),", and returns an untyped validator.\nWe then define the ",(0,n.jsx)(t.code,{children:"auctionValidatorScript"})," function, which takes ",(0,n.jsx)(t.code,{children:"AuctionParams"})," and returns the compiled Plutus Core program."]}),"\n",(0,n.jsxs)(t.p,{children:["To create the Plutus validator script for a particular auction, we call ",(0,n.jsx)(t.code,{children:"auctionValidatorScript"})," with the appropriate ",(0,n.jsx)(t.code,{children:"AuctionParams"}),".\nWe will then be able to launch the auction on-chain by submitting a transaction that outputs a script UTXO with ",(0,n.jsx)(t.code,{children:"Nothing"})," as the datum."]}),"\n",(0,n.jsxs)(t.blockquote,{children:["\n",(0,n.jsxs)(t.p,{children:["\ud83d\udccc"," ",(0,n.jsx)(t.strong,{children:"NOTE"})]}),"\n",(0,n.jsxs)(t.p,{children:["It is worth noting that we must call ",(0,n.jsx)(t.code,{children:"PlutusTx.compile"})," on the entire ",(0,n.jsx)(t.code,{children:"auctionUntypedValidator"}),", rather than applying it to ",(0,n.jsx)(t.code,{children:"params"})," before compiling, as in ",(0,n.jsx)(t.code,{children:"$$(PlutusTx.compile [||auctionUntypedValidator params||])"}),".\nThe latter won't work, because everything being compiled (inside ",(0,n.jsx)(t.code,{children:"[||...||]"}),") must be known at compile time, but ",(0,n.jsx)(t.code,{children:"params"})," is not: it can differ at runtime depending on what kind of auction we want to run.\nInstead, we compile the entire ",(0,n.jsx)(t.code,{children:"auctionUntypedValidator"})," into Plutus Core, then use ",(0,n.jsx)(t.code,{children:"liftCode"})," to lift ",(0,n.jsx)(t.code,{children:"params"})," into a Plutus Core term, and apply the compiled ",(0,n.jsx)(t.code,{children:"auctionUntypedValidator"})," to it at the Plutus Core level.\nTo do so, we need the ",(0,n.jsx)(t.code,{children:"Lift"})," instance for ",(0,n.jsx)(t.code,{children:"AuctionParams"}),", derived via ",(0,n.jsx)(t.code,{children:"PlutusTx.makeLift"}),"."]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},8453:(e,t,i)=>{i.d(t,{R:()=>o,x:()=>r});var n=i(6540);const a={},s=n.createContext(a);function o(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);