"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[8116],{5573:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var i=t(4848),r=t(8453);const a={sidebar_position:25},l="Producing a Plutus contract blueprint",s={id:"using-plutus-tx/producing-a-blueprint",title:"Producing a Plutus contract blueprint",description:"Plutus contract blueprints (CIP-0057) are used to document the binary interface of a Plutus contract in a machine-readable format (JSON schema).",source:"@site/docs/using-plutus-tx/producing-a-blueprint.md",sourceDirName:"using-plutus-tx",slug:"/using-plutus-tx/producing-a-blueprint",permalink:"/plutus/master/docs/using-plutus-tx/producing-a-blueprint",draft:!1,unlisted:!1,editUrl:"https://github.com/IntersectMBO/plutus/edit/master/docusaurus/docs/using-plutus-tx/producing-a-blueprint.md",tags:[],version:"current",sidebarPosition:25,frontMatter:{sidebar_position:25},sidebar:"tutorialSidebar",previous:{title:"Compiling Plutus Tx",permalink:"/plutus/master/docs/using-plutus-tx/compiling-plutus-tx"},next:{title:"Advanced Plutus Tx concepts",permalink:"/plutus/master/docs/category/advanced-plutus-tx-concepts"}},o={},c=[{value:"Demonstrating the usage of the <code>writeBlueprint</code> function",id:"demonstrating-the-usage-of-the-writeblueprint-function",level:2},{value:"Importing required functionality",id:"importing-required-functionality",level:2},{value:"Defining a contract blueprint value",id:"defining-a-contract-blueprint-value",level:2},{value:"Example construction",id:"example-construction",level:2},{value:"Defining a validator blueprint",id:"defining-a-validator-blueprint",level:2},{value:"Writing the blueprint to a file",id:"writing-the-blueprint-to-a-file",level:2},{value:"Annotations",id:"annotations",level:2},{value:"Resulting full blueprint example",id:"resulting-full-blueprint-example",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components},{LiteralInclude:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("LiteralInclude",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"producing-a-plutus-contract-blueprint",children:"Producing a Plutus contract blueprint"}),"\n",(0,i.jsxs)(n.p,{children:["Plutus contract blueprints (",(0,i.jsx)(n.a,{href:"https://cips.cardano.org/cip/CIP-0057",children:"CIP-0057"}),") are used to document the binary interface of a Plutus contract in a machine-readable format (JSON schema)."]}),"\n",(0,i.jsxs)(n.p,{children:["A contract blueprint can be produced by using the ",(0,i.jsx)(n.code,{children:"writeBlueprint"})," function exported by the ",(0,i.jsx)(n.code,{children:"PlutusTx.Blueprint"})," module:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"writeBlueprint\n  :: FilePath\n  -- ^ The file path where the blueprint will be written to,\n  --  e.g. '/tmp/plutus.json'\n  -> ContractBlueprint\n  -- ^ Contains all the necessary information to generate \n  -- a blueprint for a Plutus contract.\n  -> IO ()\n"})}),"\n",(0,i.jsxs)(n.h2,{id:"demonstrating-the-usage-of-the-writeblueprint-function",children:["Demonstrating the usage of the ",(0,i.jsx)(n.code,{children:"writeBlueprint"})," function"]}),"\n",(0,i.jsxs)(n.p,{children:["In order to demonstrate the usage of the ",(0,i.jsx)(n.code,{children:"writeBlueprint"})," function, let's consider the following example validator function and its interface:"]}),"\n",(0,i.jsx)(t,{file:"Cip57Blueprint.hs",language:"haskell",title:"interface types",start:"-- BEGIN interface types",end:"-- END interface types"}),"\n",(0,i.jsx)(t,{file:"Cip57Blueprint.hs",language:"haskell",title:"validator",start:"-- BEGIN validator",end:"-- END validator"}),"\n",(0,i.jsx)(n.h2,{id:"importing-required-functionality",children:"Importing required functionality"}),"\n",(0,i.jsx)(n.p,{children:"First of all, we need to import required functionality:"}),"\n",(0,i.jsx)(t,{file:"Cip57Blueprint.hs",language:"haskell",title:"imports",start:"-- BEGIN imports",end:"-- END imports"}),"\n",(0,i.jsx)(n.h2,{id:"defining-a-contract-blueprint-value",children:"Defining a contract blueprint value"}),"\n",(0,i.jsx)(n.p,{children:"Next, we define a contract blueprint value of the following type:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"data ContractBlueprint where\n  MkContractBlueprint\n    :: forall referencedTypes\n    . { contractId :: Maybe Text\n        -- ^ An optional identifier for the contract.\n      , contractPreamble :: Preamble\n        -- ^ An object with meta-information about the contract.\n      , contractValidators :: Set (ValidatorBlueprint referencedTypes)\n        -- ^ A set of validator blueprints that are part of the contract.\n      , contractDefinitions :: Definitions referencedTypes\n        -- ^ A registry of schema definitions used across the blueprint.\n      }\n    -> ContractBlueprint\n"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["\ud83d\udccc"," ",(0,i.jsx)(n.strong,{children:"NOTE"})]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"referencedTypes"})," type parameter is used to track the types used in the contract making sure their schemas are included in the blueprint and that they are referenced in a type-safe way."]}),"\n",(0,i.jsxs)(n.p,{children:["The blueprint will contain JSON schema definitions for all the types used in the contract, including the types ",(0,i.jsx)(n.strong,{children:"nested"})," within the top-level types ([MyParams], [MyDatum], [MyRedeemer]):"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Integer"})," - nested within [MyDatum] and [MyParams]."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Bool"})," - nested within [MyParams]."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This way, the [referencedTypes] type variable is inferred to be the following list:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"'[ MyParams    -- top-level type\n , MyDatum     -- top-level type\n , MyRedeemer  -- top-level type \n , Integer     -- nested type\n , Bool        -- nested type\n ]\n"})}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"We can construct a value of this type in the following way:"}),"\n",(0,i.jsx)(t,{file:"Cip57Blueprint.hs",language:"haskell",title:"contract blueprint declaration",start:"-- BEGIN contract blueprint declaration",end:"-- END contract blueprint declaration"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"contractId"})," field is optional and can be used to give a unique identifier to the contract."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"contractPreamble"})," field is a value of type ",(0,i.jsx)(n.code,{children:"PlutusTx.Blueprint.Preamble"})," and contains a meta-information\nabout the contract:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"data Preamble = MkPreamble\n  { preambleTitle         :: Text\n  -- ^ A short and descriptive title of the contract application\n  , preambleDescription   :: Maybe Text\n  -- ^ A more elaborate description\n  , preambleVersion       :: Text\n  -- ^ A version number for the project.\n  , preamblePlutusVersion :: PlutusVersion\n  -- ^ The Plutus version assumed for all validators\n  , preambleLicense       :: Maybe Text\n  -- ^ A license under which the specification\n  -- and contract code is distributed\n  }\n"})}),"\n",(0,i.jsx)(n.h2,{id:"example-construction",children:"Example construction"}),"\n",(0,i.jsx)(n.p,{children:"Here is an example construction:"}),"\n",(0,i.jsx)(t,{file:"Cip57Blueprint.hs",language:"haskell",title:"preamble declaration",start:"-- BEGIN preamble declaration",end:"-- END preamble declaration"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"contractDefinitions"})," field is a registry of schema definitions used across the blueprint.\nIt can be constructed using the ",(0,i.jsx)(n.code,{children:"deriveDefinitions"})," function which automatically constructs schema definitions for all the types it is applied to including the types nested within them."]}),"\n",(0,i.jsxs)(n.p,{children:["Since every type in the ",(0,i.jsx)(n.code,{children:"referencedTypes"})," list is going to have its derived JSON-schema in the ",(0,i.jsx)(n.code,{children:"contractDefinitions"})," registry under a certain unique ",(0,i.jsx)(n.code,{children:"DefinitionId"})," key, we need to make sure that it has the following instances:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["An instance of the ",(0,i.jsx)(n.code,{children:"GHC.Generics.Generic"})," type class:"]}),"\n"]}),"\n",(0,i.jsx)(t,{file:"Cip57Blueprint.hs",language:"haskell",title:"generic instances",start:"-- BEGIN generic instances",end:"-- END generic instances"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["An instance of the ",(0,i.jsx)(n.code,{children:"AsDefinitionId"})," type class. Most of the time it could be derived generically with the ",(0,i.jsx)(n.code,{children:"anyclass"})," strategy; for example:"]}),"\n"]}),"\n",(0,i.jsx)(t,{file:"Cip57Blueprint.hs",language:"haskell",title:"AsDefinitionId instances",start:"-- BEGIN AsDefinitionId instances",end:"-- END AsDefinitionId instances"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["An instance of the ",(0,i.jsx)(n.code,{children:"HasSchema"})," type class. If your validator exposes standard supported types like ",(0,i.jsx)(n.code,{children:"Integer"})," or ",(0,i.jsx)(n.code,{children:"Bool"}),", you don't need to define this instance. If your validator uses custom types, then you should be deriving it using the ",(0,i.jsx)(n.code,{children:"makeIsDataSchemaIndexed"})," Template Haskell function, which derives it alongside with the corresponding [ToBuiltinData]/[FromBuiltinData] instances; for example:"]}),"\n"]}),"\n",(0,i.jsx)(t,{file:"Cip57Blueprint.hs",language:"haskell",title:"makeIsDataSchemaIndexed",start:"-- BEGIN makeIsDataSchemaIndexed",end:"-- END makeIsDataSchemaIndexed"}),"\n",(0,i.jsx)(n.h2,{id:"defining-a-validator-blueprint",children:"Defining a validator blueprint"}),"\n",(0,i.jsx)(n.p,{children:"Finally, we need to define a validator blueprint for each validator used in the contract."}),"\n",(0,i.jsx)(n.p,{children:"Our contract can contain one or more validators. For each one we need to provide a description as a value of the following type:"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"data ValidatorBlueprint (referencedTypes :: [Type]) = MkValidatorBlueprint\n  { validatorTitle        :: Text\n  -- ^ A short and descriptive name for the validator.\n  , validatorDescription  :: Maybe Text\n  -- ^ An informative description of the validator.\n  , validatorRedeemer     :: ArgumentBlueprint referencedTypes\n  -- ^ A description of the redeemer format expected by this validator.\n  , validatorDatum        :: Maybe (ArgumentBlueprint referencedTypes)\n  -- ^ A description of the datum format expected by this validator.\n  , validatorParameters   :: Maybe (NonEmpty (ParameterBlueprint referencedTypes))\n  -- ^ A list of parameters required by the script.\n  , validatorCompiledCode :: Maybe ByteString\n  -- ^ A full compiled and CBOR-encoded serialized flat script.\n  }\n"})}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"In our example, this would be:"}),"\n",(0,i.jsx)(t,{file:"Cip57Blueprint.hs",language:"haskell",title:"validator blueprint declaration",start:"-- BEGIN validator blueprint declaration",end:"-- END validator blueprint declaration"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"definitionRef"})," function is used to reference a schema definition of a given type.\nIt is smart enough to discover the schema definition from the ",(0,i.jsx)(n.code,{children:"referencedType"})," list and fails to compile if the referenced type is not included."]}),"\n",(0,i.jsx)(n.h2,{id:"writing-the-blueprint-to-a-file",children:"Writing the blueprint to a file"}),"\n",(0,i.jsx)(n.p,{children:"With all the pieces in place, we can now write the blueprint to a file:"}),"\n",(0,i.jsx)(t,{file:"Cip57Blueprint.hs",language:"haskell",title:"write blueprint to file",start:"-- BEGIN write blueprint to file",end:"-- END write blueprint to file"}),"\n",(0,i.jsx)(n.h2,{id:"annotations",children:"Annotations"}),"\n",(0,i.jsxs)(n.p,{children:["Any ",(0,i.jsx)(n.a,{href:"https://cips.cardano.org/cip/CIP-0057",children:"CIP-0057"})," blueprint type definition may include ",(0,i.jsx)(n.a,{href:"https://cips.cardano.org/cip/CIP-0057#for-any-data-type",children:"optional keywords"})," to provide additional information:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"title"}),"\n",(0,i.jsx)(n.li,{children:"description"}),"\n",(0,i.jsx)(n.li,{children:"$comment"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"It's possible to add these keywords to a Blueprint type definition by annotating the Haskell type from which it's derived with a corresponding annotation:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"SchemaTitle"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"SchemaDescription"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"SchemaComment"})}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["For example, to add a title and description to the ",(0,i.jsx)(n.code,{children:"MyParams"})," type, we can use the ",(0,i.jsx)(n.code,{children:"SchemaTitle"})," and ",(0,i.jsx)(n.code,{children:"SchemaDescription"})," annotations:"]}),"\n",(0,i.jsx)(t,{file:"Cip57Blueprint.hs",language:"haskell",title:"MyParams annotations",start:"-- BEGIN MyParams annotations",end:"-- END MyParams annotations"}),"\n",(0,i.jsx)(n.p,{children:"These annotations result in the following JSON schema definition:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "title": "Title for the MyParams definition",\n  "description": "Description for the MyParams definition",\n  "dataType": "constructor",\n  "fields": [\n    { "$ref": "#/definitions/Bool" },\n    { "$ref": "#/definitions/Integer" }\n  ],\n  "index": 0\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"For sum-types, it's possible to annotate constructors:"}),"\n",(0,i.jsx)(t,{file:"Cip57Blueprint.hs",language:"haskell",title:"MyRedeemer annotations",start:"-- BEGIN MyRedeemer annotations",end:"-- END MyRedeemer annotations"}),"\n",(0,i.jsx)(n.p,{children:"These annotations result in the following JSON schema definition:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "oneOf": [\n    {\n      "$comment": "Left redeemer",\n      "dataType": "constructor",\n      "fields": [],\n      "index": 0\n    },\n    {\n      "$comment": "Right redeemer",\n      "dataType": "constructor",\n      "fields": [],\n      "index": 1\n    }\n  ]\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["It is also possible to annotate a validator's parameter or argument ",(0,i.jsx)(n.strong,{children:"type"})," (as opposed to annotating ",(0,i.jsx)(n.em,{children:"constructors"}),"):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:'{-# ANN type MyParams (SchemaTitle "Example parameter title") #-}\n{-# ANN type MyRedeemer (SchemaTitle "Example redeemer title") #-}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Then, instead of providing them literally:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:'myValidator =\n  MkValidatorBlueprint\n    { ... elided\n    , validatorParameters =\n        [ MkParameterBlueprint\n            { parameterTitle = Just "My Validator Parameters"\n            , parameterDescription = Just "Compile-time validator parameters"\n            , parameterPurpose = Set.singleton Spend\n            , parameterSchema = definitionRef @MyParams\n            }\n        ]\n    , validatorRedeemer =\n        MkArgumentBlueprint\n          { argumentTitle = Just "My Redeemer"\n          , argumentDescription = Just "A redeemer that does something awesome"\n          , argumentPurpose = Set.fromList [Spend, Mint]\n          , argumentSchema = definitionRef @MyRedeemer\n          }\n    , ... elided\n    }\n'})}),"\n",(0,i.jsx)(n.p,{children:"Use TH to have a more concise version:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"myValidator =\n  MkValidatorBlueprint\n    { ... elided\n    , validatorParameters =\n        [ $(deriveParameterBlueprint ''MyParams (Set.singleton Purpose.Spend)) ]\n    , validatorRedeemer =\n        $(deriveArgumentBlueprint ''MyRedeemer (Set.fromList [Purpose.Spend, Purpose.Mint]))\n    , ... elided\n    }\n"})}),"\n",(0,i.jsx)(n.h2,{id:"resulting-full-blueprint-example",children:"Resulting full blueprint example"}),"\n",(0,i.jsxs)(n.p,{children:["Here is the full ",(0,i.jsx)(n.a,{href:"https://cips.cardano.org/cip/CIP-0057",children:"CIP-0057"})," blueprint produced by this example:"]}),"\n",(0,i.jsx)(t,{file:"plutus.json",language:"json",title:"Complete JSON Example"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["\ud83d\udccc"," ",(0,i.jsx)(n.strong,{children:"NOTE"})]}),"\n",(0,i.jsxs)(n.p,{children:["You can find a more elaborate example of a contract blueprint in the ",(0,i.jsx)(n.code,{children:"Blueprint.Tests"})," module of the Plutus repository."]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>s});var i=t(6540);const r={},a=i.createContext(r);function l(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);