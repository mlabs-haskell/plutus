"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[6211],{3053:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>l,frontMatter:()=>o,metadata:()=>a,toc:()=>d});var s=t(4848),i=t(8453);const o={sidebar_position:15},r="ADR 2: Steppable CEK machine",a={id:"adr/adr2",title:"ADR 2: Steppable CEK machine",description:"Date: 2022-10",source:"@site/docs/adr/adr2.md",sourceDirName:"adr",slug:"/adr/adr2",permalink:"/plutus/master/docs/adr/adr2",draft:!1,unlisted:!1,editUrl:"https://github.com/IntersectMBO/plutus/edit/master/docusaurus/docs/adr/adr2.md",tags:[],version:"current",sidebarPosition:15,frontMatter:{sidebar_position:15},sidebar:"tutorialSidebar",previous:{title:"ADR 1: Record architectural decisions",permalink:"/plutus/master/docs/adr/adr1"},next:{title:"ADR 3: Sharing code between the production and debugging CEK machine",permalink:"/plutus/master/docs/adr/adr3"}},c={},d=[{value:"Authors",id:"authors",level:2},{value:"Status",id:"status",level:2},{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"Abstracting out the computation to &quot;steps&quot;",id:"abstracting-out-the-computation-to-steps",level:3},{value:"Coroutines in Haskell",id:"coroutines-in-haskell",level:3},{value:"Argument: coroutine system",id:"argument-coroutine-system",level:3},{value:"Implications",id:"implications",level:2}];function u(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"adr-2-steppable-cek-machine",children:"ADR 2: Steppable CEK machine"}),"\n",(0,s.jsx)(n.p,{children:"Date: 2022-10"}),"\n",(0,s.jsx)(n.h2,{id:"authors",children:"Authors"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"mailto:marty.stumpf@iohk.io",children:"Marty Stumpf"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"mailto:ziyang.liu@iohk.io",children:"Ziyang Liu"})}),"\n",(0,s.jsx)(n.h2,{id:"status",children:"Status"}),"\n",(0,s.jsx)(n.p,{children:"Proposed"}),"\n",(0,s.jsx)(n.h2,{id:"context",children:"Context"}),"\n",(0,s.jsx)(n.p,{children:"In order to have a minimal viable product of a debugger for Plutus, we need a CEK machine that will give us more information for debugging than our current one."}),"\n",(0,s.jsx)(n.p,{children:"In order to provide debugging information for each evaluation step, we need a steppable CEK machine.\nImplementing the steppable CEK machine is a non-trivial task and involves some design decisions.\nOne decision to make is about whether we can share the code between the production and the debugging machine.\nThat is not the scope of this ADR.\nSee the next ADR for that."}),"\n",(0,s.jsx)(n.p,{children:"This ADR proposes a design for an implementation of a steppable CEK machine.\nOf course, this doesn't mean that this is the final decision.\nThis means that the next step for us is to prototype the machine in this way - which we have reasons to believe will go well.\nWe may adjust our proposed approach depending on how the prototyping goes."}),"\n",(0,s.jsx)(n.h2,{id:"decision",children:"Decision"}),"\n",(0,s.jsx)(n.p,{children:"This section describes the proposed implementation of the debugging machine."}),"\n",(0,s.jsxs)(n.p,{children:["We first ",(0,s.jsx)(n.strong,{children:'abstract out the computation to "steps"'})," on our current machine.\nWe then ",(0,s.jsx)(n.strong,{children:"implement a coroutine system"})," to add the debugging functionalities."]}),"\n",(0,s.jsx)(n.h3,{id:"abstracting-out-the-computation-to-steps",children:'Abstracting out the computation to "steps"'}),"\n",(0,s.jsxs)(n.p,{children:["This abstraction has been implemented in ",(0,s.jsx)(n.a,{href:"https://github.com/IntersectMBO/plutus/pull/4909/",children:"PR#4909"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The current machine inlined the steps.\nWe separate each steps into separate functions.\nThey all return a ",(0,s.jsx)(n.code,{children:"CekState"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-haskell",children:"data CekState uni fun =\n    -- the next state is computing\n    Computing WordArray (Context uni fun) (Closure uni fun)\n    -- the next state is returning\n    | Returning WordArray (Context uni fun) (CekValue uni fun)\n    -- evaluation finished\n    | Terminating (Term NamedDeBruijn uni fun ())\n\ndata Closure uni fun = \n  Closure (Term NamedDeBruijn uni fun ()) (CekValEnv uni fun)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The computing step is ",(0,s.jsx)(n.code,{children:"computeCekStep"})," with the following signature:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-haskell",children:"computeCekStep\n    :: forall uni fun s\n    . (Ix fun, PrettyUni uni fun, GivenCekReqs uni fun s)\n    => WordArray\n    -> Context uni fun\n    -> Closure uni fun\n    -> CekM uni fun s (CekState uni fun)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Similarly for the returning step (",(0,s.jsx)(n.code,{children:"returnCekStep"}),").\nThen we link up all the steps with ",(0,s.jsx)(n.code,{children:"continue"}),", and the machine behaves very similar to our current one:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-haskell",children:"continue :: forall uni fun s\n    . (Ix fun, PrettyUni uni fun, GivenCekReqs uni fun s)\n    => CekState uni fun\n    -> CekM uni fun s (Term NamedDeBruijn uni fun ())\ncontinue (Computing !unbudgetedSteps ctx (Closure term env)) = do\n    state <- computeCekStep unbudgetedSteps ctx env term\n    continue state\ncontinue (Returning !unbudgetedSteps ctx val) = do\n    state <- returnCekStep unbudgetedSteps ctx val\n    continue state\ncontinue (Terminating term) = pure term\n"})}),"\n",(0,s.jsx)(n.h3,{id:"coroutines-in-haskell",children:"Coroutines in Haskell"}),"\n",(0,s.jsxs)(n.p,{children:["The next step is to add debugging capabilities between each step.\nTo do so, we implement it as a ",(0,s.jsx)(n.em,{children:"coroutine system"}),".\nA detailed introduction to coroutines in Haskell can be found in ",(0,s.jsx)(n.a,{href:"https://themonadreader.files.wordpress.com/2011/10/issue19.pdf",children:"Coroutine Pipelines"}),".\nThis section gives a brief summary."]}),"\n",(0,s.jsx)(n.p,{children:'A coroutine system is composed of multiple computations cooperatively passing data and control to one another.\nIn this instance, one computation is the user issuing commands like "step forward", and the other is the CEK machine processing the commands and performing actions like interpreting the script being debugged.\nWe\'ll refer to them as the "user computation" and the "machine computation" respectively.'}),"\n",(0,s.jsxs)(n.p,{children:["Coroutines in Haskell can be implemented using the free monad transformer, ",(0,s.jsx)(n.a,{href:"https://hackage.haskell.org/package/free/docs/Control-Monad-Trans-Free.html#t:FreeT",children:"FreeT"}),".\nThe ",(0,s.jsx)(n.code,{children:"Coroutine"})," type used in the above article is isomorphic to ",(0,s.jsx)(n.code,{children:"FreeT"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["To use ",(0,s.jsx)(n.code,{children:"FreeT f m"}),", we need two things: a suspension functor ",(0,s.jsx)(n.code,{children:"f"}),", and a base monad ",(0,s.jsx)(n.code,{children:"m"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:['The suspension functor is a pattern functor that describes the ways the user computation can suspend and pass control to the machine computation.\nEach constructor of the suspension functor should thus represent a user request, such as "step forward".\nConstructors generally follow a ',(0,s.jsx)(n.code,{children:"RequestType request (response -> a)"})," pattern."]}),"\n",(0,s.jsxs)(n.p,{children:["As an example, consider the following suspension functor (the ",(0,s.jsx)(n.code,{children:"uni"})," and ",(0,s.jsx)(n.code,{children:"fun"})," parameters are omitted for readability):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-haskell",children:"data RequestF a\n  = StepF CekState (CekState -> a)\n  | LogF Text a\n  | InputF (Command -> a)\n  deriving Functor\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"StepF"})," passes a ",(0,s.jsx)(n.code,{children:"CekState"})," to the machine computation and suspends, requesting the machine computation to progress one step, and send a ",(0,s.jsx)(n.code,{children:"CekState"})," back.\n",(0,s.jsx)(n.code,{children:"LogF"})," sends a ",(0,s.jsx)(n.code,{children:"Text"})," to the machine computation (its response type is ",(0,s.jsx)(n.code,{children:"()"})," and is omitted).\n",(0,s.jsx)(n.code,{children:"InputF"})," requests a ",(0,s.jsx)(n.code,{children:"Command"})," from the user."]}),"\n",(0,s.jsxs)(n.p,{children:["Note that this pattern is not limited to a single suspension functor and two computations.\nMultiple suspension functors and computations can be composed using ",(0,s.jsx)(n.a,{href:"https://www.cambridge.org/core/services/aop-cambridge-core/content/view/14416CB20C4637164EA9F77097909409/S0956796808006758a.pdf/data-types-a-la-carte.pdf",children:"coproducts"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The base monad ",(0,s.jsx)(n.code,{children:"m"})," is the monad the machine computation runs in.\nThe machine computation interprets each request into an ",(0,s.jsx)(n.code,{children:"m"})," action.\nIt is essentially a natural transformation from the suspension functor to ",(0,s.jsx)(n.code,{children:"m"}),".\nThis ",(0,s.jsx)(n.code,{children:"m"})," will replace our current monad ",(0,s.jsx)(n.code,{children:"CekM"}),".\nAlthough we can actually just use ",(0,s.jsx)(n.code,{children:"CekM"})," in the steppable CEK machine when we add ",(0,s.jsx)(n.code,{children:"IO"})," capabilities for debugging.\nThis is because we can convert it to/from ",(0,s.jsx)(n.code,{children:"IO"})," via ",(0,s.jsx)(n.code,{children:"unsafeSTToIO"})," and ",(0,s.jsx)(n.code,{children:"unsafeIOToST"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Suppose we define a type ",(0,s.jsx)(n.code,{children:"SteppableCekM a"})," as our base monad ",(0,s.jsx)(n.code,{children:"m"}),".\nThen the machine computation can be implemented as the following request handler function:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-haskell",children:"handle :: RequestF a -> SteppableCekM a\nhandle = \\case\n  StepF state k -> step state >>= pure . k\n  LogF text k  -> log text >> pure k\n  InputF k     -> input >>= pure . k\n"})}),"\n",(0,s.jsxs)(n.p,{children:["where ",(0,s.jsx)(n.code,{children:"step state"}),", ",(0,s.jsx)(n.code,{children:"log text"})," and ",(0,s.jsx)(n.code,{children:"input"})," return ",(0,s.jsx)(n.code,{children:"SteppableCekM"})," actions.\n",(0,s.jsx)(n.code,{children:"step"})," will likely correspond to ",(0,s.jsx)(n.code,{children:"computeCekStep"})," and ",(0,s.jsx)(n.code,{children:"returnCekStep"})," depending on the states."]}),"\n",(0,s.jsxs)(n.p,{children:["We can then use ",(0,s.jsx)(n.code,{children:"handle"})," to construct a monad morphism, interpreting the user computation (a ",(0,s.jsx)(n.code,{children:"FreeT"})," structure) into a ",(0,s.jsx)(n.code,{children:"SteppableCekM"})," action:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-haskell",children:"runSteppableCek :: FreeT RequestF SteppableCekM a -> SteppableCekM a\nrunSteppableCek userAction = do\n  runFreeT userAction >>= \\case\n    Pure res -> pure res\n    Free req -> handle req >>= runSteppableCek\n"})}),"\n",(0,s.jsxs)(n.p,{children:["To construct the user computation, ",(0,s.jsx)(n.code,{children:"FreeT RequestF SteppableCekM"}),", we first provide helper functions for constructing ",(0,s.jsx)(n.code,{children:"RequestF"}),"s and lifting them into the ",(0,s.jsx)(n.code,{children:"FreeT"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-haskell",children:"stepF :: Monad m => CekState -> FreeT RequestF m CekState\nstepF state = liftF (StepF state id)\n\nlogF :: Monad m => Text -> FreeT RequestF m ()\nlogF text = liftF (LogF text ())\n\ninputF :: Monad m => FreeT RequestF m Command\ninputF = liftF (InputF id)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Then we can implement the user computation like this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-haskell",children:'userComputation :: CekState -> FreeT RequestF SteppableCekM ()\n    userComputation currentState = do\n      cmd <- inputF\n      case cmd of\n        Step -> do\n          logF "Received Step command"\n          mState <- stepF currentState\n          userComputation mState\n        ...\n'})}),"\n",(0,s.jsxs)(n.p,{children:["We enter the debugging mode with the input UPLC program or term to debug with ",(0,s.jsx)(n.code,{children:"enterDebug"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-haskell",children:"enterDebug :: UPLCTerm -> FreeT RequestF SteppableCekM ()\nenterDebug termToDebug = do\n  state <- stepF (Computing (toWordArray 0) NoFrame (Closure term Env.empty))\n  userComputation state\n  ...\n"})}),"\n",(0,s.jsx)(n.h3,{id:"argument-coroutine-system",children:"Argument: coroutine system"}),"\n",(0,s.jsx)(n.p,{children:"Why a coroutine system?\nIn short, structuring the code this way will ease our future work.\nSome of the advantages are mentioned above already.\nHere is a summary:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The debugger is naturally a coroutine, where one routine is the user and the other is the CEK machine, and they take turns to suspend and pass data and control to each other in a debugging session. The literature has contributed a good way to design/implement a coroutine. It makes sense to implement a well studied design."}),"\n",(0,s.jsxs)(n.li,{children:["We can probably reuse the same monad (",(0,s.jsx)(n.code,{children:"CekM"}),") in the steppable CEK machine, because we can convert it to/from ",(0,s.jsx)(n.code,{children:"IO"})," via ",(0,s.jsx)(n.code,{children:"unsafeSTToIO"})," and ",(0,s.jsx)(n.code,{children:"unsafeIOToST"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["It should be easier when we add more functionalities because multiple suspension functors and computations can be composed using ",(0,s.jsx)(n.a,{href:"https://www.cambridge.org/core/services/aop-cambridge-core/content/view/14416CB20C4637164EA9F77097909409/S0956796808006758a.pdf/data-types-a-la-carte.pdf",children:"coproducts"}),"."]}),"\n",(0,s.jsx)(n.li,{children:"This should also play nicely when we implement Debug Adapter Protocol for the debugger later on."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"implications",children:"Implications"}),"\n",(0,s.jsx)(n.p,{children:"In summary, we proposed to implement the debugging machine as a coroutine system with 'steps'.\nThis implies that:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"We have to maintain the CEK machine (eg, we need to check its conformance)"}),"\n",(0,s.jsx)(n.li,{children:"We will add a debugger for our users providing them with more information at each evaluation step"}),"\n",(0,s.jsx)(n.li,{children:"We will need to write some tests to ensure that the debugging machine continuously outputs reasonable information."}),"\n"]})]})}function l(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var s=t(6540);const i={},o=s.createContext(i);function r(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);