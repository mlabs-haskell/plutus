"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[9043],{7454:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>r,contentTitle:()=>o,default:()=>d,frontMatter:()=>l,metadata:()=>a,toc:()=>c});var t=n(4848),i=n(8453);const l={sidebar_position:20},o="Compiling Plutus Tx",a={id:"using-plutus-tx/compiling-plutus-tx",title:"Compiling Plutus Tx",description:"Strictly speaking, while the majority of simple Haskell will work, only a subset of Haskell is supported by the Plutus Tx compiler.",source:"@site/docs/using-plutus-tx/compiling-plutus-tx.md",sourceDirName:"using-plutus-tx",slug:"/using-plutus-tx/compiling-plutus-tx",permalink:"/plutus/master/docs/using-plutus-tx/compiling-plutus-tx",draft:!1,unlisted:!1,editUrl:"https://github.com/IntersectMBO/plutus/edit/master/docusaurus/docs/using-plutus-tx/compiling-plutus-tx.md",tags:[],version:"current",sidebarPosition:20,frontMatter:{sidebar_position:20},sidebar:"tutorialSidebar",previous:{title:"Writing Plutus Tx programs",permalink:"/plutus/master/docs/using-plutus-tx/writing-plutus-tx-programs"},next:{title:"Producing a Plutus contract blueprint",permalink:"/plutus/master/docs/using-plutus-tx/producing-a-blueprint"}},r={},c=[{value:"GHC Extensions, Flags and Pragmas",id:"ghc-extensions-flags-and-pragmas",level:2},{value:"Extensions",id:"extensions",level:3},{value:"Flags",id:"flags",level:3},{value:"Plutus Tx compiler options",id:"plutus-tx-compiler-options",level:3},{value:"Pragmas",id:"pragmas",level:3}];function u(e){const s={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.h1,{id:"compiling-plutus-tx",children:"Compiling Plutus Tx"}),"\n",(0,t.jsx)(s.admonition,{type:"warning",children:(0,t.jsx)(s.p,{children:"Strictly speaking, while the majority of simple Haskell will work, only a subset of Haskell is supported by the Plutus Tx compiler.\nThe Plutus Tx compiler will tell you if you are attempting to use an unsupported component."})}),"\n",(0,t.jsx)(s.h2,{id:"ghc-extensions-flags-and-pragmas",children:"GHC Extensions, Flags and Pragmas"}),"\n",(0,t.jsx)(s.p,{children:"Plutus Tx is a subset of Haskell and is compiled to Untyped Plutus Core by the Plutus Tx compiler, a GHC (Glasgow Haskell Compiler) plugin."}),"\n",(0,t.jsx)(s.p,{children:"In order to ensure the success and correct compilation of Plutus Tx programs, all Plutus Tx modules (that is, Haskell modules that contain code to be compiled by the Plutus Tx compiler) should use the following GHC extensions, flags and pragmas."}),"\n",(0,t.jsx)(s.h3,{id:"extensions",children:"Extensions"}),"\n",(0,t.jsxs)(s.p,{children:["Plutus Tx modules should use the ",(0,t.jsx)(s.code,{children:"Strict"})," extension: :"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"    {-# LANGUAGE Strict #-}\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Unlike in Haskell, function applications in Plutus Tx are strict.\nIn other words, when evaluating ",(0,t.jsx)(s.code,{children:"(\\x -> 42) (3 + 4)"})," the expression ",(0,t.jsx)(s.code,{children:"3 + 4"})," is evaluated first, before evaluating the function body (",(0,t.jsx)(s.code,{children:"42"}),"), even though ",(0,t.jsx)(s.code,{children:"x"})," is not used in the function body.\nThe ",(0,t.jsx)(s.code,{children:"Strict"})," extension ensures that let bindings and patterns are also (by default) strict, for instance, evaluating ",(0,t.jsx)(s.code,{children:"let x = 3 + 4 in 42"})," evaluates ",(0,t.jsx)(s.code,{children:"3 + 4"})," first, even though ",(0,t.jsx)(s.code,{children:"x"})," is not used."]}),"\n",(0,t.jsxs)(s.p,{children:["Bang patterns and lazy patterns can be used to explicitly specify whether a let binding is strict or non-strict, as in ",(0,t.jsx)(s.code,{children:"let !x = 3 + 4 in 42"})," (strict) and ",(0,t.jsx)(s.code,{children:"let ~x = 3 + 4 in 42"})," (non-strict).\nAt this time, it is not possible to make function applications non-strict: ",(0,t.jsx)(s.code,{children:"(\\(~x) -> 42) (3 + 4)"})," still evaluates ",(0,t.jsx)(s.code,{children:"3 + 4"})," strictly."]}),"\n",(0,t.jsx)(s.p,{children:"Making let bindings strict by default has the following advantages:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["It makes let bindings and function applications semantically equivalent. For example, ",(0,t.jsx)(s.code,{children:"let x = 3 + 4 in 42"})," has the same semantics as ",(0,t.jsx)(s.code,{children:"(\\x -> 42) (3 + 4)"}),".\nThis is what one would come to expect, as it is the case in most other programming languages, regardless of whether the language is strict or non-strict."]}),"\n",(0,t.jsxs)(s.li,{children:["Untyped Plutus Core programs, which are compiled from Plutus Tx, are not evaluated lazily (unlike Haskell), that is, there is no memoization of the results of evaluated expressions.\nThus using non-strict bindings can cause an expression to be inadvertently evaluated for an unbounded number of times.\nConsider ",(0,t.jsx)(s.code,{children:"let x = <expensive> in \\y -> x + y"}),".\nIf ",(0,t.jsx)(s.code,{children:"x"})," is non-strict, ",(0,t.jsx)(s.code,{children:"<expensive>"})," will be evalutated every time ",(0,t.jsx)(s.code,{children:"\\y -> x + y"})," is applied to an argument, which means it can be evaluated 0 times, 1 time, 2 times, or any number of times (this is not the case if lazy evaluation was employed).\nOn the other hand, if ",(0,t.jsx)(s.code,{children:"x"})," is strict, it is always evaluated once, which is at most one more time than what is necessary."]}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"flags",children:"Flags"}),"\n",(0,t.jsxs)(s.p,{children:["GHC has a variety of optimization flags, many of which are on by default.\nAlthough Plutus Tx is, syntactically, a subset of Haskell, it has different semantics and a different evaluation strategy (Haskell: non-strict semantics, call by need; Plutus Tx: strict semantics, call by value). As a result, some GHC optimizations are not helpful for Plutus Tx programs, and can even be harmful, in the sense that it can make Plutus Tx programs less efficient, or fail to be compiled.\nAn example is the full laziness optimization, controlled by GHC flag ",(0,t.jsx)(s.code,{children:"-ffull-laziness"}),", which floats let bindings out of lambdas whenever possible.\nSince Untyped Plutus Core does not employ lazy evaluation, the full laziness optimization is usually not beneficial, and can sometimes make a Plutus Tx program more expensive.\nConversely, some GHC features must be turned on in order to ensure Plutus Tx programs are compiled successfully."]}),"\n",(0,t.jsx)(s.p,{children:"All Plutus Tx modules should use the following GHC flags:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"    -fno-ignore-interface-pragmas\n    -fno-omit-interface-pragmas\n    -fno-full-laziness\n    -fno-spec-constr\n    -fno-specialise\n    -fno-strictness\n    -fno-unbox-strict-fields\n    -fno-unbox-small-strict-fields\n"})}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"-fno-ignore-interface-pragmas"})," and ",(0,t.jsx)(s.code,{children:"-fno-omit-interface-pragmas"})," ensure unfoldings of Plutus Tx functions are available.\nThe rest are GHC optimizations that are generally bad for Plutus Tx, and should thus be turned off."]}),"\n",(0,t.jsx)(s.p,{children:"These flags can be specified either in a Haskell module, for example:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"    {-# OPTIONS_GHC -fno-ignore-interface-pragmas #-}\n"})}),"\n",(0,t.jsxs)(s.p,{children:["or in a build file.\nFor example, if your project is built using Cabal, you can add the flags to the ",(0,t.jsx)(s.code,{children:".cabal"})," files, like so:"]}),"\n",(0,t.jsxs)(s.blockquote,{children:["\n",(0,t.jsx)(s.p,{children:"ghc-options:"}),"\n",(0,t.jsx)(s.p,{children:":   -fno-ignore-interface-pragmas"}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"plutus-tx-compiler-options",children:"Plutus Tx compiler options"}),"\n",(0,t.jsxs)(s.blockquote,{children:["\n",(0,t.jsxs)(s.p,{children:["\ud83d\udccc"," ",(0,t.jsx)(s.strong,{children:"NOTE"})]}),"\n",(0,t.jsxs)(s.p,{children:["This section only covers GHC flags, not Plutus Tx compiler flags.\nA number of options can be passed to the Plutus Tx compiler.\nSee ",(0,t.jsx)(s.a,{href:"/plutus/master/docs/reference/plutus-tx-compiler-options",children:"Reference > Plutus Tx Compiler Options"})," for details."]}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"pragmas",children:"Pragmas"}),"\n",(0,t.jsxs)(s.p,{children:["All functions and methods should have the ",(0,t.jsx)(s.code,{children:"INLINEABLE"})," pragma, so that their unfoldings are made available to the Plutus Tx compiler."]}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:"-fexpose-all-unfoldings"})," flag also makes GHC expose all unfoldings, but unfoldings exposed this way can be more optimized than unfoldings exposed via ",(0,t.jsx)(s.code,{children:"INLINEABLE"}),".\nIn general, we do not want GHC to perform optimizations, since GHC optimizes a program based on the assumption that it has non-strict semantics and is evaluated lazily (call by need), which is not true for Plutus Tx programs.\nTherefore, ",(0,t.jsx)(s.code,{children:"INLINEABLE"})," is preferred over ",(0,t.jsx)(s.code,{children:"-fexpose-all-unfoldings"}),", even though the latter is simpler."]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"-fexpose-all-unfoldings"})," can be useful for functions that are generated by GHC and do not have the ",(0,t.jsx)(s.code,{children:"INLINEABLE"})," pragma.\n",(0,t.jsx)(s.code,{children:"-fspecialise"})," and ",(0,t.jsx)(s.code,{children:"-fspec-constr"})," are two examples of optimizations that can generate such functions.\nThe most reliable solution, however, is to simply turn these optimizations off.\nAnother option is to bump ",(0,t.jsx)(s.code,{children:"-funfolding-creation-threshold"})," to make it more likely for GHC to retain unfoldings for functions without the ",(0,t.jsx)(s.code,{children:"INLINEABLE"})," pragma.\n",(0,t.jsx)(s.code,{children:"-fexpose-all-unfoldings"})," should be used as a last resort."]})]})}function d(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>o,x:()=>a});var t=n(6540);const i={},l=t.createContext(i);function o(e){const s=t.useContext(l);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(l.Provider,{value:s},e.children)}}}]);