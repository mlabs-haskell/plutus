"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[3614],{109:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>a,toc:()=>l});var t=i(4848),s=i(8453);const r={sidebar_position:10},o="Optimization techniques for Plutus scripts",a={id:"reference/script-optimization-techniques",title:"Optimization techniques for Plutus scripts",description:"Identifying problem areas",source:"@site/docs/reference/script-optimization-techniques.md",sourceDirName:"reference",slug:"/reference/script-optimization-techniques",permalink:"/plutus/master/docs/reference/script-optimization-techniques",draft:!1,unlisted:!1,editUrl:"https://github.com/IntersectMBO/plutus/edit/master/docusaurus/docs/reference/script-optimization-techniques.md",tags:[],version:"current",sidebarPosition:10,frontMatter:{sidebar_position:10},sidebar:"tutorialSidebar",previous:{title:"Plutus Tx compiler options",permalink:"/plutus/master/docs/reference/plutus-tx-compiler-options"},next:{title:"Examples",permalink:"/plutus/master/docs/reference/examples"}},c={},l=[{value:"Identifying problem areas",id:"identifying-problem-areas",level:2},{value:"Using strict let-bindings to avoid recomputation",id:"using-strict-let-bindings-to-avoid-recomputation",level:2},{value:"Specializing higher-order functions",id:"specializing-higher-order-functions",level:2},{value:"Common sub-expression elimination",id:"common-sub-expression-elimination",level:2},{value:"Using <code>error</code> for faster failure",id:"using-error-for-faster-failure",level:2}];function u(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"optimization-techniques-for-plutus-scripts",children:"Optimization techniques for Plutus scripts"}),"\n",(0,t.jsx)(n.h2,{id:"identifying-problem-areas",children:"Identifying problem areas"}),"\n",(0,t.jsxs)(n.p,{children:["In order to identify which parts of the script are responsible for significant resource consumption, you can use the ",(0,t.jsx)(n.code,{children:"profiling support"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"using-strict-let-bindings-to-avoid-recomputation",children:"Using strict let-bindings to avoid recomputation"}),"\n",(0,t.jsx)(n.p,{children:"Let-bindings in Haskell are translated to strict let-bindings in Plutus IR, unless they look like they might do computation, in which case they are translated to non-strict let-bindings.\nThis is to avoid triggering effects (e.g. errors) at unexpected times."}),"\n",(0,t.jsxs)(n.p,{children:["However, non-strict let-bindings are less efficient.\nThey do not evaluate their right-hand side immediately, instead they do so where the variable is used.\nBut they are not ",(0,t.jsx)(n.em,{children:"lazy"})," (evaluating the right-hand side at most once), instead it may be evaluated once each time it is used.\nYou may wish to explicitly mark let-bindings as strict in Haskell to avoid this."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-haskell",children:"-- This may be compiled non-strictly, which could result\n-- in it being evaluated multiple times. However, it will\n-- not be evaluated if we take the branch where it is not used.\nlet x = y + z\nin if b then x + x else 1\n\n-- This will be compiled strictly, but this will mean it\n-- is evaluated even if we take the branch where it is not used.\nlet !x = y + z\nin if b then x + x else 1\n"})}),"\n",(0,t.jsx)(n.h2,{id:"specializing-higher-order-functions",children:"Specializing higher-order functions"}),"\n",(0,t.jsx)(n.p,{children:"The use of higher-order functions is a common technique to facilitate code reuse.\nHigher-order functions are widely used in the Plutus libraries but can be less efficient than specialized versions."}),"\n",(0,t.jsxs)(n.p,{children:["For instance, the Plutus function ",(0,t.jsx)(n.code,{children:"findOwnInput"})," makes use of the higher-order function ",(0,t.jsx)(n.code,{children:"find"})," to search for the current script input."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-haskell",children:"findOwnInput :: ScriptContext -> Maybe TxInInfo\nfindOwnInput ScriptContext{scriptContextTxInfo=TxInfo{txInfoInputs},\n             scriptContextPurpose=Spending txOutRef} =\n    find (\\TxInInfo{txInInfoOutRef} -> txInInfoOutRef == txOutRef) txInfoInputs\nfindOwnInput _ = Nothing\n"})}),"\n",(0,t.jsx)(n.p,{children:"This can be rewritten with a recursive function specialized to the specific check in question."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-haskell",children:"findOwnInput :: ScriptContext -> Maybe TxInInfo\nfindOwnInput ScriptContext{scriptContextTxInfo=TxInfo{txInfoInputs},\n             scriptContextPurpose=Spending txOutRef} = go txInfoInputs\n    where\n        go [] = Nothing\n        go (i@TxInInfo{txInInfoOutRef} : rest) = if txInInfoOutRef == txOutRef\n                                                 then Just i\n                                                 else go rest\nfindOwnInput _ = Nothing\n"})}),"\n",(0,t.jsx)(n.h2,{id:"common-sub-expression-elimination",children:"Common sub-expression elimination"}),"\n",(0,t.jsx)(n.p,{children:"When several instances of identical expressions exist within a function's body, it's worth replacing them with a single (strict) let-bound variable to hold the computed value."}),"\n",(0,t.jsxs)(n.p,{children:["In this example, the cost of storing and retrieving ",(0,t.jsx)(n.code,{children:"n * c"})," in a single variable is significantly less than recomputing it several times."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-haskell",children:"let a' = a `divide` n * c\n    -- occurrence 1\n    b' = b * (n * c)\n    -- occurrence 2\n    C' = c + (n * c)\nin\n  foo a' b' c' n\n\n-- Only one occurrence\nlet !t_mul = n * c\n    a' = a `divide` t_mul\n    b' = b * t_mul\n    c' = c + t_mul\nin\n  foo a' b' c' n\n"})}),"\n",(0,t.jsxs)(n.h2,{id:"using-error-for-faster-failure",children:["Using ",(0,t.jsx)(n.code,{children:"error"})," for faster failure"]}),"\n",(0,t.jsxs)(n.p,{children:["Plutus scripts have access to one impure effect, ",(0,t.jsx)(n.code,{children:"error"}),", which immediately terminates the script evaluation and will fail validation.\nThis failure is very fast, but it is also unrecoverable, so only use it in cases where you want to fail the entire validation if there is a failure."]}),"\n",(0,t.jsxs)(n.p,{children:["The Plutus libraries have some functions that fail with ",(0,t.jsx)(n.code,{children:"error"}),".\nUsually these are given an ",(0,t.jsx)(n.code,{children:"unsafe"})," prefix to their name.\nFor example, ",(0,t.jsx)(n.code,{children:"PlutusTx.IsData.Class.FromData"})," parses a value of type ",(0,t.jsx)(n.code,{children:"Data"}),", returning the result in a ",(0,t.jsx)(n.code,{children:"Maybe"})," value to indicate whether it succeeded or failed; whereas ",(0,t.jsx)(n.code,{children:"PlutusTx.IsData.Class.UnsafeFromData"})," does the same but fails with ",(0,t.jsx)(n.code,{children:"error"}),"."]})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var t=i(6540);const s={},r=t.createContext(s);function o(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);