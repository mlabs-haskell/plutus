"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[3359],{95:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>n,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var i=s(4848),a=s(8453);const r={sidebar_position:5},n="Writing basic validator scripts",o={id:"working-with-scripts/writing-basic-validator-scripts",title:"Writing basic validator scripts",description:"Validator scripts are the programs that can be used to lock transaction outputs on the chain.",source:"@site/docs/working-with-scripts/writing-basic-validator-scripts.md",sourceDirName:"working-with-scripts",slug:"/working-with-scripts/writing-basic-validator-scripts",permalink:"/plutus/master/docs/working-with-scripts/writing-basic-validator-scripts",draft:!1,unlisted:!1,editUrl:"https://github.com/IntersectMBO/plutus/edit/master/docusaurus/docs/working-with-scripts/writing-basic-validator-scripts.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Working with scripts",permalink:"/plutus/master/docs/category/working-with-scripts"},next:{title:"Writing basic minting policies",permalink:"/plutus/master/docs/working-with-scripts/writing-basic-minting-policies"}},l={},c=[{value:"Validator arguments",id:"validator-arguments",level:2},{value:"The <code>Data</code> type",id:"the-data-type",level:2},{value:"Signaling failure",id:"signaling-failure",level:2},{value:"Validator functions",id:"validator-functions",level:2},{value:"Plutus script context versions",id:"plutus-script-context-versions",level:2}];function d(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",strong:"strong",ul:"ul",...(0,a.R)(),...e.components},{LiteralInclude:s}=t;return s||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("LiteralInclude",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"writing-basic-validator-scripts",children:"Writing basic validator scripts"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"/plutus/master/docs/reference/glossary#validator-script",children:"Validator scripts"})," are the programs that can be used to lock transaction outputs on the chain.\nValidator scripts are ",(0,i.jsx)(t.a,{href:"/plutus/master/docs/reference/glossary#plutus-core",children:"Plutus Core"})," programs, but we can use ",(0,i.jsx)(t.a,{href:"/plutus/master/docs/reference/glossary#plutus-tx",children:"Plutus Tx"})," to write them easily in Haskell.\nPlease review ",(0,i.jsx)(t.a,{href:"/plutus/master/docs/using-plutus-tx/writing-plutus-tx-programs",children:"Writing Plutus Tx programs"})," before going through this topic."]}),"\n",(0,i.jsx)(t.h2,{id:"validator-arguments",children:"Validator arguments"}),"\n",(0,i.jsx)(t.p,{children:"Validators receive some information from the validating node:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["The ",(0,i.jsx)(t.a,{href:"/plutus/master/docs/reference/glossary#redeemer",children:"redeemer"}),", which is some script-specific data specified by the party spending the output."]}),"\n",(0,i.jsxs)(t.li,{children:["The ",(0,i.jsx)(t.a,{href:"/plutus/master/docs/reference/glossary#datum",children:"datum"}),", which is some script-specific data specified by the party who created the output."]}),"\n",(0,i.jsxs)(t.li,{children:["The ",(0,i.jsx)(t.a,{href:"/plutus/master/docs/reference/glossary#script-context",children:"script context"}),", which contains a representation of the spending transaction, as well as the index of the input whose validator is currently being run."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["The validator is a function which receives these three inputs as ",(0,i.jsx)(t.em,{children:"arguments"}),". The validating node is responsible for passing them in and running the validator."]}),"\n",(0,i.jsxs)(t.h2,{id:"the-data-type",children:["The ",(0,i.jsx)(t.code,{children:"Data"})," type"]}),"\n",(0,i.jsx)(t.p,{children:"But how are the validator's arguments passed?\nDifferent scripts are going to expect different sorts of values in their datums and redeemers."}),"\n",(0,i.jsxs)(t.p,{children:["The answer is that we pass the arguments as a ",(0,i.jsx)(t.em,{children:"generic"})," structured data type ",(0,i.jsx)(t.code,{children:"PlutusCore.Data.Data"}),".\n",(0,i.jsx)(t.code,{children:"Data"})," is designed to make it easy to encode structured data into it, and is essentially a subset of CBOR."]}),"\n",(0,i.jsxs)(t.p,{children:["Validator scripts take three arguments of type ",(0,i.jsx)(t.code,{children:"Data"}),".\nSince ",(0,i.jsx)(t.code,{children:"Data"})," is represented as a builtin type in Plutus Core, we use a special Haskell type ",(0,i.jsx)(t.code,{children:"BuiltinData"})," rather than the underlying ",(0,i.jsx)(t.code,{children:"Data"})," type."]}),"\n",(0,i.jsxs)(t.p,{children:["However, you will typically not want to use ",(0,i.jsx)(t.code,{children:"BuiltinData"})," directly in your program, rather you will want to use your own datatypes.\nWe can easily convert to and from ",(0,i.jsx)(t.code,{children:"BuiltinData"})," with the ",(0,i.jsx)(t.code,{children:"PlutusTx.IsData.Class.ToData"}),", ",(0,i.jsx)(t.code,{children:"PlutusTx.IsData.Class.FromData"}),", and ",(0,i.jsx)(t.code,{children:"PlutusTx.IsData.Class.UnsafeFromData"})," typeclasses.\nYou usually don't need to write your own instances of these classes.\nInstead, you can use the ",(0,i.jsx)(t.code,{children:"unstableMakeIsData"})," or ",(0,i.jsx)(t.code,{children:"makeIsDataIndexed"})," Template Haskell functions to generate one."]}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsxs)(t.p,{children:["\ud83d\udccc"," ",(0,i.jsx)(t.strong,{children:"NOTE"})]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"PlutusTx.IsData.Class.UnsafeFromData"})," class provides ",(0,i.jsx)(t.code,{children:"unsafeFromBuiltinData"}),", which is the same as ",(0,i.jsx)(t.code,{children:"fromBuiltinData"}),", but is faster and fails with ",(0,i.jsx)(t.code,{children:"error"})," rather than returning a ",(0,i.jsx)(t.code,{children:"Maybe"}),".\nWe'll use ",(0,i.jsx)(t.code,{children:"unsafeFromBuiltinData"})," in this tutorial, but sometimes the other version is useful."]}),"\n"]}),"\n",(0,i.jsx)(s,{file:"BasicValidators.hs",language:"haskell",title:"Code snippet from BasicValidators.hs",start:"-- BLOCK1",end:"-- BLOCK2"}),"\n",(0,i.jsx)(t.h2,{id:"signaling-failure",children:"Signaling failure"}),"\n",(0,i.jsxs)(t.p,{children:["The most important thing that a validator can do is ",(0,i.jsx)(t.em,{children:"fail"}),".\nThis indicates that the attempt to spend the output is invalid and that transaction validation should fail.\nA validator succeeds if it does not explicitly fail.\nThe actual value returned by the validator is irrelevant."]}),"\n",(0,i.jsxs)(t.p,{children:["How does a validator fail?\nIt does so by using the ",(0,i.jsx)(t.code,{children:"PlutusTx.Builtins.error"})," builtin.\nSome other builtins may also trigger failure if they are used incorrectly (for example, ",(0,i.jsx)(t.code,{children:"1/0"}),")."]}),"\n",(0,i.jsx)(t.h2,{id:"validator-functions",children:"Validator functions"}),"\n",(0,i.jsxs)(t.p,{children:["We write validator scripts as Haskell functions, which we compile with Plutus Tx into Plutus Core.\nThe type of a validator function is ",(0,i.jsx)(t.code,{children:"BuiltinData -> BuiltinData -> BuiltinData -> ()"}),", that is, a function which takes three arguments of type ",(0,i.jsx)(t.code,{children:"BuiltinData"}),", and returns a value of type ",(0,i.jsx)(t.code,{children:"()"}),' ("unit" or "the empty tuple" -- since the return type doesn\'t matter we just pick something trivial).']}),"\n",(0,i.jsx)(t.p,{children:"Here are two examples of simple validators that always succeed and always fail, respectively:"}),"\n",(0,i.jsx)(s,{file:"BasicValidators.hs",language:"haskell",title:"Code snippet from BasicValidators.hs",start:"-- BLOCK2",end:"-- BLOCK3"}),"\n",(0,i.jsxs)(t.p,{children:["If we want to write a validator that uses types other than ",(0,i.jsx)(t.code,{children:"BuiltinData"}),", we'll need to use the functions from ",(0,i.jsx)(t.code,{children:"PlutusTx.IsData.Class.FromData"})," to decode them.\nImportantly, ",(0,i.jsx)(t.code,{children:"unsafeFromBuiltinData"})," can fail: in our example, if the ",(0,i.jsx)(t.code,{children:"BuiltinData"})," in the second argument is ",(0,i.jsx)(t.em,{children:"not"})," a correctly encoded ",(0,i.jsx)(t.code,{children:"Date"}),", then it will fail the whole validation with ",(0,i.jsx)(t.code,{children:"error"}),", which is usually what we want if we have bad arguments."]}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsxs)(t.p,{children:["\ud83d\udd34"," ",(0,i.jsx)(t.strong,{children:"Important"})]}),"\n",(0,i.jsxs)(t.p,{children:["Unfortunately, there's no way to provide failure diagnostics when a validator fails on chain\u2014it just fails.\nHowever, since transaction validation is entirely deterministic, you'll always be informed of this before you submit the transaction to the chain, so you can debug it locally using ",(0,i.jsx)(t.code,{children:"traceError"}),"."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Here's an example that uses our date types to check whether the date which was provided is less than the stored limit in the datum."}),"\n",(0,i.jsx)(s,{file:"BasicValidators.hs",language:"haskell",title:"Code snippet from BasicValidators.hs",start:"-- BLOCK3",end:"-- BLOCK4"}),"\n",(0,i.jsx)(t.h2,{id:"plutus-script-context-versions",children:"Plutus script context versions"}),"\n",(0,i.jsxs)(t.p,{children:["Validators have access to the ",(0,i.jsx)(t.a,{href:"/plutus/master/docs/reference/glossary#script-context",children:"script context"})," as their third argument.\nEach version of Plutus validators are differentiated only by their ",(0,i.jsx)(t.code,{children:"ScriptContext"})," argument."]}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsxs)(t.p,{children:["See this example from the file ",(0,i.jsx)(t.code,{children:"MustSpendScriptOutput.hs"})," (lines 340 to 422) showing code addressing ",(0,i.jsx)(t.a,{href:"https://github.com/IntersectMBO/plutus-apps/blob/05e394fb6188abbbe827ff8a51a24541a6386422/plutus-contract/test/Spec/TxConstraints/MustSpendScriptOutput.hs#L340-L422",children:"Versioned Policies for both Plutus V1 and Plutus V2"}),"."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"The script context gives validators a great deal of power, because it allows them to inspect other inputs and outputs of the current transaction.\nFor example, here is a validator that will only accept the transaction if a particular payment is made as part of it."}),"\n",(0,i.jsx)(s,{file:"BasicValidators.hs",language:"haskell",title:"Code snippet from BasicValidators.hs",start:"-- BLOCK4",end:"-- BLOCK5"}),"\n",(0,i.jsx)(t.p,{children:"This makes use of some useful functions for working with script contexts."})]})}function u(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>n,x:()=>o});var i=s(6540);const a={},r=i.createContext(a);function n(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:n(e.components),i.createElement(r.Provider,{value:t},e.children)}}}]);